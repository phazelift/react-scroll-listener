"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.5.1
(function () {
  // react-scroll-listener - listen for and handle scroll events in React applications
  // includes: ScrollListener.Mixin and/or ScrollListenerMixin
  // MIT License
  // Copyright (c) 2015 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  var ScrollListener, ScrollListenerMixin, _scrollListeners, getScrollListener, types, uuid;

  types = require('types.js');
  uuid = require('uuid');

  ScrollListener = function () {
    var DEFAULT_TIMEOUT_DELAY; // ScrollListener

    var ScrollListener = /*#__PURE__*/function () {
      function ScrollListener(settings) {
        _classCallCheck(this, ScrollListener);

        // TODO: this should make possible overwriting an existing handler
        // setScrollStartHandler: ( id, handler) ->
        // setScrollEndHandler: ( id, handler) ->
        this._onHostScrollEnd = this._onHostScrollEnd.bind(this);
        this._onHostScroll = this._onHostScroll.bind(this);
        settings = types.forceObject(settings);
        this.scrollHost = types.forceObject(settings.host);
        this.scrollStartHandlers = {};
        this.scrollEndHandlers = {};
        this.scrollTop = 0;
        this.isScrolling = false;
        this.scrollTimeoutDelay = types.forceNumber(settings.delay, DEFAULT_TIMEOUT_DELAY);
        this._scrollTimeout = void 0;
        this.scrollListenerSet = false;
      }

      _createClass(ScrollListener, [{
        key: "addScrollEventListener",
        value: function addScrollEventListener() {
          if (this.scrollListenerSet) {
            return;
          }

          if (!this.scrollHost.addEventListener) {
            if ('undefined' === typeof window) {
              return console.log('ScrollListener::addScrollEventListener -> bad or missing host/window, cannot add event-listener!');
            } else {
              this.scrollHost = window;
            }
          }

          this.scrollHost.addEventListener('scroll', this._onHostScroll);
          return this.scrollListenerSet = true;
        }
      }, {
        key: "removeScrollEventListener",
        value: function removeScrollEventListener() {
          return this.scrollHost.removeEventListener('scroll', this._onHostScroll);
        }
      }, {
        key: "addScrollHandler",
        value: function addScrollHandler(id, handler, onScrollEnd) {
          id = types.forceString(id);

          if (!id) {
            return console.log('ScrollListener::addScrollHandler -> cannot add handler without id!');
          }

          handler = types.forceFunction(handler);

          if (onScrollEnd && !this.scrollEndHandlers[id]) {
            this.scrollEndHandlers[id] = handler;
          } else if (!this.scrollStartHandlers[id]) {
            this.scrollStartHandlers[id] = handler;
          }

          return this.addScrollEventListener();
        }
      }, {
        key: "addScrollStartHandler",
        value: function addScrollStartHandler(id, handler) {
          return this.addScrollHandler(id, handler);
        }
      }, {
        key: "addScrollEndHandler",
        value: function addScrollEndHandler(id, handler) {
          return this.addScrollHandler(id, handler, true);
        }
      }, {
        key: "removeScrollStartHandler",
        value: function removeScrollStartHandler(id) {
          return delete this.scrollStartHandlers[id];
        }
      }, {
        key: "removeScrollEndHandler",
        value: function removeScrollEndHandler(id) {
          return delete this.scrollEndHandlers[id];
        }
      }, {
        key: "removeScrollHandlers",
        value: function removeScrollHandlers() {
          this.scrollStartHandlers = {};
          return this.scrollEndHandlers = {};
        }
      }, {
        key: "_onHostScrollEnd",
        value: function _onHostScrollEnd(event) {
          var handler, results;

          if (this.scrollTop === this.scrollHost.pageYOffset) {
            clearTimeout(this._scrollTimeout);
            this.isScrolling = false;
            results = [];

            for (handler in this.scrollEndHandlers) {
              results.push(this.scrollEndHandlers[handler](event));
            }

            return results;
          }
        }
      }, {
        key: "_onHostScroll",
        value: function _onHostScroll(event) {
          var handler;
          this.isScrolling = true;
          this.scrollTop = this.scrollHost.pageYOffset;
          clearTimeout(this._scrollTimeout);

          for (handler in this.scrollStartHandlers) {
            this.scrollStartHandlers[handler](event);
          }

          return this._scrollTimeout = setTimeout(this._onHostScrollEnd.bind(this, event), this.scrollTimeoutDelay);
        }
      }]);

      return ScrollListener;
    }();

    ;
    DEFAULT_TIMEOUT_DELAY = 300;
    return ScrollListener;
  }.call(this); //	 ScrollListener.Mixin:


  _scrollListeners = {};

  getScrollListener = function getScrollListener(id) {
    return _scrollListeners[id] || (_scrollListeners[id] = new ScrollListener());
  };

  ScrollListenerMixin = function ScrollListenerMixin(id) {
    var Mixin, scrollEndId, scrollStartId;
    scrollStartId = uuid.v4();
    scrollEndId = uuid.v4();
    return Mixin = {
      scrollListener: getScrollListener(types.forceString(id, 'generic')),
      componentDidMount: function componentDidMount() {
        this.scrollListener.addScrollStartHandler(scrollStartId, this.onScrollStart);
        return this.scrollListener.addScrollEndHandler(scrollEndId, this.onScrollEnd);
      },
      componentWillUnmount: function componentWillUnmount() {
        this.scrollListener.removeScrollStartHandler(scrollStartId);
        return this.scrollListener.removeScrollEndHandler(scrollEndId);
      }
    };
  };

  ScrollListener.componentWillMount = function () {
    throw new Error('You are trying to use ScrollListenerMixin as an object, but it\'s a Function! Check the mixin for usage details.');
  };

  ScrollListener.Mixin = ScrollListenerMixin;
  ScrollListener.ScrollListenerMixin = ScrollListenerMixin;
  module.exports = ScrollListener;
}).call(void 0);